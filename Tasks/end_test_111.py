"""
1.	Оценить асимптотическую сложность приведенного ниже алгоритма:
a = len(arr) - 1
out = list()
while a > 0:
    out.append(arr[a])
    a = a // 1.7
out.merge_sort()

добавление O(1), в данном случае n//1.7 имхо похоже на O(log_2 n) -- по факту основани 1,7
сортировка слиянием в конце - O(n Logn)

итого O(n2 log n)
"""

"""
2.	Считалочка
Дано N человек, считалка из K слогов. Считалка начинает считать с первого человека. Когда считалка досчитывает до k-го слога,
человек, на котором она остановилась, вылетает. Игра происходит до тех пор, пока не останется последний человек.
Для данных N и К дать номер последнего оставшегося человека.
"""
n = 9
k = 3
i = 0
res = [0 for _ in range(n)]

# print(res)
_char = 0  # перебор слогов
_end = True
_pers = 0  # перебор людей
while _end:
	_pers = 0
	while _pers < n and _end:
		i += 1
		# _char = 0  # перебор слогов
		while _char < k and _end:
			# print(f"i:{i}  j:{_pers}  res:{res} \tpers{_char} ")
			if _pers == n:
				_pers = 0
			if res[_pers] == 0:
				_char += 1
				_pers += 1
			else:
				_pers += 1
		# вычеркивам человека
		if res[_pers - 1] == 0:
			res[_pers - 1] = i
			_char = 0

		if all(res):
			_end = False
			print(f"Last: {_pers}")

		if _end:
			print(f"i:{i} {res[_pers - 1]} \t{res}")
	if i == 2:
		print(i)

"""
5.	Задача консенсуса DNA ридов
При чтении DNA последовательностей могут возникать единичные ошибки, выражающиеся в неверной букве в строке.
Для решения данной проблемы требуемое место читается несколько раз, после чего строится консенсус-строка,
в которой на каждом месте будет стоять тот символ, что чаще всего встречался в этом месте суммарно во всех чтениях. Т.е. для строк
ATTA
ACTA
AGCA
ACAA
консенсус-строка будет ACTA (в первой ячейке чаще всего встречалась A, во второй – C, в третьей – Т, в четвертой – снова А).
Для входного списка из N строк одинаковой длины построить консенсус-строку


6.	Аренда ракет
Вы – компания, дающая в аренду ракеты. Каждый день к вам приходит список заявок на использование ракет в виде: (час_начала, час_конца), (час_начала, час_конца), ...
Если аренда ракеты заканчивается в час X, то в этот же час ее уже можно взять в аренду снова (т.е. час_начала может начинаться с Х).
Дано: список заявок на использование ракет
Задача: вывести ответ, хватит ли вам одной ракеты, чтобы удовлетворить все заявки на этот день


need_time = []
need_time.append({"s": 9, "e": 12})
need_time.append({"s": 16, "e": 17})
need_time.append({"s": 12, "e": 15})
need_time.append({"s": 16, "e": 24})
print(need_time[0:])

# s = need_time[0]['s']
# e = need_time[0]['e']
# print( s, e)

time_used = [0 for _ in range(25)]
# print(time_used, len(time_used))
res = 0
for i in need_time:
	for t in range(i['s']+1,i['e']+1):
	# 	print(i, t)
		if time_used[t] == 0:
			time_used[t] = 1
		else:
			print(f"Пересечение времени {t}")
			time_used[t] += 1
			res = -1

if res == -1:
	print('Не хватает одной ракеты')
else:
	print('Ok')


print(time_used)
"""

"""
7.	Сорт
Дано: массив из 10**6 целых чисел, каждое из которых лежит на отрезке [13, 25].
Задача: отсортировать массив наиболее эффективным способом
"""
